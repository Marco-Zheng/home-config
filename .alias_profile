#!/bin/bash

# ===== Env =====

if [[ "$PROJECT_HOME" == "" ]] then
    echo "Missing Environment Variable `PROJECT_HOME`"
fi

# Golang
if [[ "$PROJECT_HOME" != "" ]] then
    export GOPATH="$PROJECT_HOME/go"
    export PATH="$GOPATH/bin:$PATH"
fi

# Istio

if [[ "$HOME/Projects/istio/istio-$ISTIO_VERSION/bin" != "" ]] then
    export PATH=$HOME/Projects/istio/istio-$ISTIO_VERSION/bin:$PATH
    source /Users/dozer/Projects/istio/istio-$ISTIO_VERSION/tools/_istioctl

    if [[ ! -f "/tmp/istio-$ISTIO_VERSION.json" ]] then
        istioctl profile dump demo -o json > /tmp/istio-$ISTIO_VERSION.json
    fi
fi

# Kubernetes

export PATH="$HOME/.krew/bin:$PATH"


# ===== Misc =====

alias tt="tmux -CC attach || tmux -CC"

alias mysql="mysql --default-character-set utf8"

alias dlv-attach="dlv --listen=:2345 --headless=true --api-version=2 attach"

# ===== Kubernetes =====

# Format: image-name[,group-name]
KUBE_CACHED_IMAGES=(
    aylei/debug-agent:latest,debug
    dozer47528/devops-toolkits-docker:latest,debug
    nginx:stable,debug
)

if [[ "$HOME/Projects/istio/istio-$ISTIO_VERSION/bin" != "" ]] then
    KUBE_CACHED_IMAGES+=(
        istio/proxyv2:${ISTIO_VERSION},istio
        istio/pilot:${ISTIO_VERSION},istio
        quay.io/kiali/kiali:$(istioctl profile dump demo -o json | jq '..|.kiali?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
        grafana/grafana:$(istioctl profile dump demo -o json | jq '..|.grafana?.image?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
        prom/prometheus:$(istioctl profile dump demo -o json | jq '..|.prometheus?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
        jaegertracing/all-in-one:$(istioctl profile dump demo -o json | jq '..|.jaeger?.tag?' | grep -v null | sed 's/"//g'),istio-telemetry
    )
fi

# Load images to minikube, do not need to run it after create Minikube cluster everytime.
minikube-cache-image(){
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        i=$(echo $i | awk -F ',' '{print $1}')
        docker pull $i
        if [[ $i =~ "/" ]] && ! test -f ~/.minikube/cache/images/${i/:/_}; then
            mkdir -p ~/.minikube/cache/images/${i/:/_}
            rm -r ~/.minikube/cache/images/${i/:/_}
        fi
        docker save $i -o ~/.minikube/cache/images/${i/:/_}
        minikube cache add $i
    done
}

# Load host docker images to Kind on-demand, need to run it after create Kind cluster everytime.
# You pass the group name to this command like: `kind-load-images nginx`
kind-load-images(){
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        image=$(echo $i | awk -F ',' '{print $1}')
        group=$(echo $i | awk -F ',' '{print $2}')
        if [[ $1 == $group ]] || [[ $1 == "all" ]]; then
            docker pull $image
            kind load docker-image $image
        fi
    done
}

# Completions for `kind-load-images` command

_kind-load-images_completions(){
    COMPREPLY+=("all")
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        image=$(echo $i | awk -F ',' '{print $1}')
        group=$(echo $i | awk -F ',' '{print $2}')
        if [[ $image != "" ]] && (! [[ " ${COMPREPLY[@]} " =~ " ${group} " ]]); then
            COMPREPLY+=("$group")
        fi
    done
}
complete -F _kind-load-images_completions kind-load-images


pod-name(){
    kubectl get pod -l app=$1 -o jsonpath="{.items[0].metadata.name}"
}

kk() {
    uuid=$(uuidgen)
    if [[ $1 == "default" ]]; then
        cp ${HOME}/.kube/config ~/.tmp/${uuid}
    else
        cp ${HOME}/.kube/clusters/$1 ~/.tmp/${uuid}
    fi
    export KUBECONFIG=${HOME}/.tmp/${uuid}
}

_kk_completions(){
   COMPREPLY+=("default")
   COMPREPLY+=(`ls ~/.kube/clusters`)
}

complete -F _kk_completions kk
