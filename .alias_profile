#!/bin/bash

# ===== Env =====

if [[ "$PROJECT_HOME" == "" ]] then
    echo "Missing Environment Variable `PROJECT_HOME`"
fi

# Golang
if [[ "$PROJECT_HOME" != "" ]] then
    export GOPATH="$PROJECT_HOME/go"
    export PATH="$GOPATH/bin:$PATH"
fi

# Istio
export ISTIO_HOME=$PROJECT_HOME/istio/istio-$ISTIO_VERSION
if [[ -d "$ISTIO_HOME" ]] then
    export PATH=$ISTIO_HOME/bin:$PATH
    source $ISTIO_HOME/tools/_istioctl
fi

# Kubernetes

export PATH="$HOME/.krew/bin:$PATH"


# ===== Misc =====

alias tt="tmux -CC attach || tmux -CC"

if command -v kubens > /dev/null
then
    alias kn="kubens"
else
    alias kn="kubectl ns"
fi

alias mysql="mysql --default-character-set utf8"

alias dlv-attach="dlv --listen=:2345 --headless=true --api-version=2 attach"

alias kind="KUBECONFIG=$HOME/.kube/config kind"

alias minikube="KUBECONFIG=$HOME/.kube/config minikube"

# ===== Trip Desktop =====

trip-desktop-enable-proxy(){
    LAN_IP=$(ip addr show $(ip -4 route ls | grep default | awk '{print $5}') | grep 'inet ' |  perl -pe 's/(.*inet )(\d+\.\d+\.\d+\.\d+)(\/\d+.*)/$2/g')
    ssh trip.dozer.cc -- "cat /etc/resolv.conf | perl -pe 's/^nameserver.*/nameserver 198.18.0.2/g' | sudo tee /etc/resolv.conf"
    ssh trip.dozer.cc -- "sudo ip route add default via $LAN_IP"
}

trip-desktop-disable-proxy(){
    ssh trip.dozer.cc -- "cat /etc/resolv.conf | perl -pe 's/^nameserver.*/nameserver 127.0.0.53/g' | sudo tee /etc/resolv.conf"
    ssh trip.dozer.cc -- "sudo ip route delete default"
}

# Forward desktop minikube
trip-desktop-forward-minikube(){
    scp trip.dozer.cc:/home/dozer/.kube/config ~/.kube/clusters/trip-desktop
    mkdir -p ~/.kube/clusters/trip-desktop-cert
    scp trip.dozer.cc:/home/dozer/.minikube/ca.crt ~/.kube/clusters/trip-desktop-cert/ca.crt
    scp trip.dozer.cc:/home/dozer/.minikube/profiles/minikube/client.crt ~/.kube/clusters/trip-desktop-cert/client.crt
    scp trip.dozer.cc:/home/dozer/.minikube/profiles/minikube/client.key ~/.kube/clusters/trip-desktop-cert/client.key
    yq w -i ~/.kube/clusters/trip-desktop 'clusters[0].cluster.server' https://127.0.0.1:8443
    yq w -i ~/.kube/clusters/trip-desktop 'clusters[0].cluster.certificate-authority' $HOME/.kube/clusters/trip-desktop-cert/ca.crt
    yq w -i ~/.kube/clusters/trip-desktop 'users[0].user.client-certificate' $HOME/.kube/clusters/trip-desktop-cert/client.crt
    yq w -i ~/.kube/clusters/trip-desktop 'users[0].user.client-key' $HOME/.kube/clusters/trip-desktop-cert/client.key
    cat ~/.kube/clusters/trip-desktop | perl -pe 's/minikube/trip-desktop/g' | tee ~/.kube/clusters/trip-desktop > /dev/null
    echo "kubeconfig: $HOME/.kube/clusters/trip-desktop"
    ssh -NT -L 127.0.0.1:8443:$(ssh trip.dozer.cc -- minikube ip):8443 trip.dozer.cc || true
    rm -rf $HOME/.kube/clusters/trip-desktop
    rm -rf $HOME/.kube/clusters/trip-desktop-cert
}

# ===== Kubernetes =====

# Format: image-name[,group-name]
KUBE_CACHED_IMAGES=(
    aylei/debug-agent:latest,debug
    dozer47528/devops-toolkits-docker:latest,debug
    dozer47528/devops-toolkits-docker:benchmark,debug
    nginx:stable,debug
    golang:1.15,debug
)

if [[ -d "$ISTIO_HOME" ]] && [[ -x "$(command -v jq)" ]] then
    KUBE_CACHED_IMAGES+=(
        docker.io/istio/proxyv2:${ISTIO_VERSION},istio
        istio/proxyv2:${ISTIO_VERSION},istio
        istio/pilot:${ISTIO_VERSION},istio
        $(cat $ISTIO_HOME/samples/addons/prometheus.yaml | grep "jimmidyson/configmap-reload:" | perl -pe 's/.*"(.*)".*/$1/g'),istio-telemetry
        $(cat $ISTIO_HOME/samples/addons/prometheus.yaml | grep "prom/prometheus:" | perl -pe 's/.*"(.*)".*/$1/g'),istio-telemetry
        $(cat $ISTIO_HOME/samples/addons/grafana.yaml | grep "grafana/grafana:" | perl -pe 's/.*"(.*)".*/$1/g'),istio-telemetry
        $(cat $ISTIO_HOME/samples/bookinfo/platform/kube/bookinfo.yaml | grep "docker.io/istio/examples-bookinfo-details-v1:" | sed 's/image: //g' ),istio-demo
        $(cat $ISTIO_HOME/samples/bookinfo/platform/kube/bookinfo.yaml | grep "docker.io/istio/examples-bookinfo-ratings-v1:" | sed 's/image: //g' ),istio-demo
        $(cat $ISTIO_HOME/samples/bookinfo/platform/kube/bookinfo.yaml | grep "docker.io/istio/examples-bookinfo-reviews-v1:" | sed 's/image: //g' ),istio-demo
        $(cat $ISTIO_HOME/samples/bookinfo/platform/kube/bookinfo.yaml | grep "docker.io/istio/examples-bookinfo-reviews-v2:" | sed 's/image: //g' ),istio-demo
        $(cat $ISTIO_HOME/samples/bookinfo/platform/kube/bookinfo.yaml | grep "docker.io/istio/examples-bookinfo-reviews-v3:" | sed 's/image: //g' ),istio-demo
        $(cat $ISTIO_HOME/samples/bookinfo/platform/kube/bookinfo.yaml | grep "docker.io/istio/examples-bookinfo-productpage-v1:" | sed 's/image: //g' ),istio-demo
    )
fi

# Load images to minikube, do not need to run it after create Minikube cluster everytime.
minikube-cache-image(){
    minikube cache list | xargs minikube cache delete
    rm -rf ~/.minikube/cache/images/*
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        i=$(echo $i | awk -F ',' '{print $1}')
        docker pull $i
        if [[ $i =~ "/" ]] && ! test -f ~/.minikube/cache/images/${i/:/_}; then
            mkdir -p ~/.minikube/cache/images/${i/:/_}
            rm -r ~/.minikube/cache/images/${i/:/_}
        fi
        docker save $i -o ~/.minikube/cache/images/${i/:/_}
        minikube cache add $i
    done
}

# Load host docker images to Kind on-demand, need to run it after create Kind cluster everytime.
# You pass the group name to this command like: `kind-load-images nginx`
kind-load-images(){
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        image=$(echo $i | awk -F ',' '{print $1}')
        group=$(echo $i | awk -F ',' '{print $2}')
        if [[ $1 == $group ]] || [[ $1 == "all" ]]; then
            docker pull $image
            kind load docker-image $image
        fi
    done
}

# Completions for `kind-load-images` command

_kind-load-images_completions(){
    COMPREPLY+=("all")
    for i in ${KUBE_CACHED_IMAGES[@]}; do
        image=$(echo $i | awk -F ',' '{print $1}')
        group=$(echo $i | awk -F ',' '{print $2}')
        if [[ $image != "" ]] && (! [[ " ${COMPREPLY[@]} " =~ " ${group} " ]]); then
            COMPREPLY+=("$group")
        fi
    done
}
complete -F _kind-load-images_completions kind-load-images


pod-name(){
    kubectl get pod -l app=$1 -o jsonpath="{.items[0].metadata.name}"
}

kk() {
    uuid=$(uuidgen)
    if [[ $1 == "default" ]]; then
        cp ${HOME}/.kube/config ~/.tmp/${uuid}
    else
        cp ${HOME}/.kube/clusters/$1 ~/.tmp/${uuid}
    fi
    export KUBECONFIG=${HOME}/.tmp/${uuid}
}

_kk_completions(){
   COMPREPLY+=("default")
   COMPREPLY+=(`ls ~/.kube/clusters`)
}

complete -F _kk_completions kk


# External Disk

external-mount(){

MOUNT_SOURCE_HOME=/Volumes/External

MOUNT_TARGECTS=(
    "/Users/dozer/.minikube"
    "/Users/dozer/Library/Containers/com.docker.docker"
    "/Users/dozer/Projects"
)

for t in ${MOUNT_TARGECTS[@]}; do
    mkdir -p "${MOUNT_SOURCE_HOME}${t}"
    rm -r "${t}"
    ln -s "${MOUNT_SOURCE_HOME}${t}" "${t}"
done

}
